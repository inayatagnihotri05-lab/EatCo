<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>EcoRun üåø ‚Äî Pro</title>
  <style>
    :root{--accent:#2e8b57;--bg1:#bde9ff;--bg2:#e7fdff}
    html,body{height:100%;margin:0;font-family:Inter, Poppins, system-ui, Arial;background:linear-gradient(180deg,var(--bg1),var(--bg2));}
    .ui-top{display:flex;align-items:center;justify-content:space-between;padding:10px 16px;gap:12px}
    .brand{font-weight:700;color:#11402a}
    .controls{color:#155e2c;font-weight:600}
    #gameCanvas{display:block;width:100%;height:calc(100vh - 110px);touch-action:none;background:transparent}
    #facts{position:fixed;left:50%;bottom:12px;transform:translateX(-50%);background:rgba(255,255,255,0.88);padding:8px 14px;border-radius:12px;font-size:13px;color:#124b32;backdrop-filter:blur(6px);box-shadow:0 8px 24px rgba(17,75,47,0.06);z-index:40}
    .kbd{display:inline-block;padding:6px 8px;background:#fff;border-radius:8px;border:1px solid rgba(0,0,0,0.06);font-weight:700}
    @media (max-width:480px){#gameCanvas{height:60vh}#facts{font-size:12px}}
  </style>
</head>
<body>
  <div class="ui-top">
    <div class="brand">EcoRun üåç ‚Äî Pro</div>
    <div class="controls">Controls: <span class="kbd">SPACE</span> / Tap &nbsp; M to mute</div>
  </div>
  <canvas id="gameCanvas" aria-label="EcoRun game area"></canvas>
  <div id="facts">Loading eco facts...</div>

<script>
(() => {
  // ======= CONFIG =======
  const BASE_SPEED = 5;           // base forward speed
  const GRAVITY = 0.95;           // gravity
  const PLAYER_EMOJI = 'üèÉ‚Äç‚ôÇÔ∏è';    // emoji runner
  const PLAYER_SIZE = 78;         // emoji draw size
  const INITIAL_SPAWN_TRASH_MS = 1600;
  const INITIAL_SPAWN_GOOD_MS = 2200;
  const STREAK_WINDOW = 1400;     // ms to continue streak

  // ======= CANVAS SETUP =======
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });

  function setCanvasCssHeight(){
    const top = document.querySelector('.ui-top').offsetHeight;
    const h = Math.max(window.innerHeight - top - 24, 320);
    canvas.style.height = h + 'px';
  }
  function resizeCanvas(){
    setCanvasCssHeight();
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    groundY = rect.height - 120;
    // keep player on ground
    if(player) player.y = Math.min(player.y, groundY - player.h);
  }
  window.addEventListener('resize', resizeCanvas);

  // ======= PARALLAX =======
  let clouds = [], mountainX = 0, treeX = 0;
  function initParallax(){
    clouds = []; const w = canvas.getBoundingClientRect().width;
    for(let i=0;i<6;i++) clouds.push({x: Math.random()*w, y: 40 + Math.random()*100, r: 30+Math.random()*30, speed: 0.18 + Math.random()*0.22});
    mountainX = 0; treeX = 0;
  }

  function drawParallax(){
    const w = canvas.getBoundingClientRect().width, h = canvas.getBoundingClientRect().height;
    // sky
    const sky = ctx.createLinearGradient(0,0,0,h);
    sky.addColorStop(0,'#cfeffd'); sky.addColorStop(1,'#eafdfc');
    ctx.fillStyle = sky; ctx.fillRect(0,0,w,h);

    // clouds
    ctx.fillStyle='rgba(255,255,255,0.95)';
    clouds.forEach(c => { c.x -= c.speed; if(c.x < -200) c.x = w + 200; ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.arc(c.x+c.r*0.6,c.y-c.r*0.35,c.r*0.8,0,Math.PI*2); ctx.fill(); });

    // mountains (mid)
    mountainX -= 0.9; if(mountainX <= -w) mountainX = 0; ctx.fillStyle='#8bb5d9'; drawMountains(mountainX); drawMountains(mountainX + w);

    // trees (front)
    treeX -= currentSpeed*0.6; if(treeX <= -w) treeX = 0; drawTrees(treeX); drawTrees(treeX + w);

    // ground stripe
    ctx.fillStyle='rgba(0,0,0,0.06)'; ctx.fillRect(0, h-110, w, 110);
    ctx.fillStyle='#f6e58d'; ctx.fillRect(0, h-85, w, 10);
  }
  function drawMountains(x){ const h = canvas.getBoundingClientRect().height; ctx.beginPath(); ctx.moveTo(x, h-150); ctx.lineTo(x+260, h-380); ctx.lineTo(x+520, h-150); ctx.fill(); }
  function drawTrees(x){ const h = canvas.getBoundingClientRect().height; for(let i=0;i<10;i++){ const tx = x + i*160; ctx.fillStyle='#6b3b1a'; ctx.fillRect(tx+12, h-160, 16, 60); ctx.fillStyle='#1f7a2a'; ctx.beginPath(); ctx.moveTo(tx, h-160); ctx.lineTo(tx+30, h-220); ctx.lineTo(tx+60, h-160); ctx.fill(); } }

  // ======= PLAYER (emoji style) =======
  let groundY = 0;
  let player = { x: 140, y: 0, w: PLAYER_SIZE, h: PLAYER_SIZE, vy: 0, jumping: false };
  function drawPlayer(){ ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = `${player.w}px serif`; // shadow
    ctx.beginPath(); ctx.ellipse(player.x + player.w/2, player.y + player.h*0.75, player.w*0.6, 10, 0,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.08)'; ctx.fill(); ctx.fillStyle='#000'; ctx.fillText(PLAYER_EMOJI, player.x + player.w/2, player.y + player.h/2 + 6); ctx.restore(); }
  function updatePlayer(){ player.vy += GRAVITY; player.y += player.vy; const maxY = groundY - player.h; if(player.y >= maxY){ player.y = maxY; player.vy = 0; player.jumping = false; } }
  function doJump(){ if(!gameRunning) return; if(player.jumping) return; player.jumping = true; player.vy = -20 - Math.random()*6; playSfx('jump'); }

  // ======= ITEMS & OBSTACLES (emoji) =======
  let obstacles = [], items = [];
  function spawnObstacle(){ const size = 56 + Math.round(Math.random()*20); const y = groundY - size + 8; const pool = ['üóëÔ∏è','üóëÔ∏è','üß∂','ü•§','üçü']; const emoji = pool[Math.floor(Math.random()*pool.length)]; obstacles.push({x: canvas.getBoundingClientRect().width + 80, y, w: size, h: size, emoji, speed: currentSpeed + Math.random()*1.8}); }
  function spawnGood(){ const size = 48; const y = groundY - 140 - Math.random()*70; const pool = [{e:'‚ôªÔ∏è',p:1},{e:'üçé',p:1},{e:'ü•¶',p:1},{e:'ü•á',p:3}]; const pick = pool[Math.floor(Math.random()*pool.length)]; items.push({x: canvas.getBoundingClientRect().width + 80, y, w: size, h: size, emoji: pick.e, points: pick.p, speed: currentSpeed - 0.8 + Math.random()*1.4, bounce:0, dir:1}); }

  function rectColl(a,b){ return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h); }

  // ======= PARTICLES (leaf burst) =======
  let particles = [];
  function spawnParticles(x,y,emoji){ for(let i=0;i<14;i++){ particles.push({x, y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.9)*6, life: 500 + Math.random()*600, size: 8 + Math.random()*10, char: (Math.random()<0.6)?'üçÉ':'‚ú®' }); } }
  function updateParticles(dt){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.18; p.life -= dt; if(p.life <= 0) particles.splice(i,1); } }
  function drawParticles(){ ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; particles.forEach(p=>{ ctx.font = `${p.size}px serif`; ctx.fillText(p.char, p.x, p.y); }); ctx.restore(); }

  // ======= SFX (WebAudio library simple map) =======
  let audioCtx = null; let muted = false;
  function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
  function playSfx(name){ if(muted) return; ensureAudio(); if(name==='jump'){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.setValueAtTime(880,audioCtx.currentTime); g.gain.setValueAtTime(0.0001,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.18,audioCtx.currentTime+0.02); o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+0.12); }
    if(name==='collect'){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(1200,audioCtx.currentTime); g.gain.setValueAtTime(0.0001,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.15,audioCtx.currentTime+0.02); o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+0.14);} 
    if(name==='hit'){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.setValueAtTime(140,audioCtx.currentTime); g.gain.setValueAtTime(0.0001,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.18,audioCtx.currentTime+0.02); o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+0.22);} }

  // ======= STREAK / MULTIPLIER LOGIC =======
  let lastCollectTime = 0; let streakCount = 0; let streakMultiplier = 1;
  function registerCollect(t, points){ const now = t || performance.now(); if(now - lastCollectTime < STREAK_WINDOW){ streakCount++; } else { streakCount = 1; }
    lastCollectTime = now; streakMultiplier = 1 + Math.floor(Math.max(0, streakCount-1)/2); // every 2 in streak adds +1 multiplier
    const gained = points * streakMultiplier; score += gained; // add to score
    // small popup particle
    spawnParticles(player.x + player.w/2, player.y + 20);
    playSfx('collect');
  }

  // ======= DIFFICULTY RAMP =======
  let elapsed = 0; let currentSpeed = BASE_SPEED; let spawnTrashMs = INITIAL_SPAWN_TRASH_MS; let spawnGoodMs = INITIAL_SPAWN_GOOD_MS;
  function difficultyTick(dt){ elapsed += dt; // every 12s increase speed slightly
    currentSpeed = BASE_SPEED + Math.floor(elapsed / 12000) * 0.9; // increases stepwise
    // gradually reduce spawn intervals but clamp
    spawnTrashMs = Math.max(700, INITIAL_SPAWN_TRASH_MS - Math.floor(elapsed/10000)*120);
    spawnGoodMs = Math.max(700, INITIAL_SPAWN_GOOD_MS - Math.floor(elapsed/11000)*90);
  }

  // ======= GAME STATE & HUD =======
  let score = 0, health = 3, best = parseInt(localStorage.getItem('eatco_best')||'0',10)||0; let gameRunning=false, gameOver=false; let trashTimer = null, goodTimer = null; let lastTime = 0;

  function startGame(){ if(gameRunning && !gameOver) return; // reset
    obstacles.length = 0; items.length = 0; particles.length = 0; score = 0; health = 3; elapsed = 0; streakCount = 0; streakMultiplier = 1; lastCollectTime = 0; gameRunning=true; gameOver=false; player.y = groundY - player.h; player.vy = 0; if(trashTimer) clearInterval(trashTimer); if(goodTimer) clearInterval(goodTimer); trashTimer = setInterval(() => spawnObstacle(), spawnTrashMs); goodTimer = setInterval(() => spawnGood(), spawnGoodMs); playSfx('collect'); }
  function stopGame(){ gameRunning=false; gameOver=true; if(trashTimer) clearInterval(trashTimer); if(goodTimer) clearInterval(goodTimer); if(score>best){ best = score; localStorage.setItem('eatco_best', String(best)); } }

  function drawHUD(){ ctx.save(); ctx.fillStyle='#08361f'; ctx.font='20px Poppins, sans-serif'; ctx.textAlign='left'; ctx.fillText(`Score: ${score}`, 18, 30); ctx.textAlign='right'; ctx.fillText(`Best: ${best}`, canvas.getBoundingClientRect().width - 18, 30); // hearts
    ctx.textAlign='left'; ctx.font='18px serif'; ctx.fillText('‚ù§'.repeat(health), 18, 58); // streak
    ctx.textAlign='center'; ctx.font='16px Poppins, sans-serif'; ctx.fillStyle='#145434'; ctx.fillText(streakMultiplier>1?`Streak x${streakMultiplier}`:'', canvas.getBoundingClientRect().width - 110, 58);
    ctx.restore(); }

  function drawStart(){ const w = canvas.getBoundingClientRect().width, h = canvas.getBoundingClientRect().height; ctx.save(); ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,w,h); ctx.fillStyle='white'; ctx.textAlign='center'; ctx.font='36px Poppins, sans-serif'; ctx.fillText('EcoRun üåø', w/2, h/2 - 40); ctx.font='18px Poppins, sans-serif'; ctx.fillText('Tap or SPACE to start ‚Ä¢ Collect ‚ôªÔ∏è / üçé ‚Ä¢ Avoid üóëÔ∏è', w/2, h/2 + 6); ctx.restore(); }
  function drawGameOver(){ const w = canvas.getBoundingClientRect().width, h = canvas.getBoundingClientRect().height; ctx.save(); ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,w,h); ctx.fillStyle='white'; ctx.textAlign='center'; ctx.font='34px Poppins, sans-serif'; ctx.fillText('Game Over', w/2, h/2 - 30); ctx.font='20px Poppins, sans-serif'; ctx.fillText(`Score: ${score}`, w/2, h/2 + 6); ctx.fillText('Tap or SPACE to restart', w/2, h/2 + 46); ctx.restore(); }

  // ======= MAIN LOOP =======
  function mainLoop(ts){ if(!lastTime) lastTime = ts; const dt = ts - lastTime; lastTime = ts; if(!gameRunning && !gameOver){ // still draw background & start overlay
      drawParallax(); drawStart(); // keep small animation
      requestAnimationFrame(mainLoop); return; }
    // update difficulty
    difficultyTick(dt);
    // clear
    const w = canvas.getBoundingClientRect().width, h = canvas.getBoundingClientRect().height; ctx.clearRect(0,0,w,h);
    // parallax
    drawParallax();
    // update items
    for(let i = items.length -1; i>=0; i--){ const it = items[i]; it.x -= it.speed; it.bounce += 0.16 * it.dir; if(it.bounce>8||it.bounce<-3) it.dir *= -1; // draw
        ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = `${it.w}px serif`; ctx.fillText(it.emoji, it.x + it.w/2, it.y + it.h/2 + it.bounce); ctx.restore();
        // collide
        if(rectColl(it, player)){ registerCollect(performance.now(), it.points); items.splice(i,1); }
        if(it.x + it.w < -120) items.splice(i,1);
    }
    // update obstacles
    for(let i = obstacles.length -1; i>=0; i--){ const ob = obstacles[i]; ob.x -= ob.speed; ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = `${ob.w}px serif`; ctx.fillText(ob.emoji, ob.x + ob.w/2, ob.y + ob.h/2); ctx.restore(); if(rectColl(ob, player)){ // hit
          obstacles.splice(i,1); health--; playSfx('hit'); spawnParticles(player.x + player.w/2, player.y + player.h/2); if(health<=0){ stopGame(); } }
        if(ob.x + ob.w < -120) obstacles.splice(i,1);
    }
    // player & particles
    updatePlayer(); drawPlayer(); updateParticles(dt); drawParticles();
    // HUD
    drawHUD();
    // win-check (optional celebration)
    if(score >= 999999){} // placeholder
    // continue
    requestAnimationFrame(mainLoop);
  }

  // ======= INPUT =======
  window.addEventListener('keydown', e => { if(e.code === 'Space'){ e.preventDefault(); if(!gameRunning){ startGame(); } else if(gameOver){ startGame(); } else { doJump(); } } if(e.code === 'KeyM'){ muted = !muted; } });
  canvas.addEventListener('touchstart', e => { e.preventDefault(); if(!gameRunning){ startGame(); } else if(gameOver){ startGame(); } else { doJump(); } }, {passive:false});
  canvas.addEventListener('mousedown', e => { if(!gameRunning){ startGame(); } else if(gameOver){ startGame(); } else { doJump(); } });

  // ======= SPAWNER MANAGEMENT (update intervals when difficulty changes) =======
  function startSpawners(){ if(window._trashTimer) clearInterval(window._trashTimer); if(window._goodTimer) clearInterval(window._goodTimer); window._trashTimer = setInterval(spawnObstacle, Math.max(700, INITIAL_SPAWN_TRASH_MS - Math.floor(elapsed/10000)*120)); window._goodTimer = setInterval(spawnGood, Math.max(700, INITIAL_SPAWN_GOOD_MS - Math.floor(elapsed/11000)*90)); }
  // call this whenever difficulty updated; we'll re-set inside difficultyTick if thresholds crossed

  // link difficultyTick with spawn rate adjustments
  let lastDifficultyStep = 0;
  function difficultyTick(dt){ elapsed += dt; const step = Math.floor(elapsed/12000); currentSpeed = BASE_SPEED + step*0.9; if(step !== lastDifficultyStep){ lastDifficultyStep = step; startSpawners(); } }

  // ======= STREAK SFX + collect wrapper =======
  function registerCollect(now, points){ const t = now || performance.now(); if(t - lastCollectTime < STREAK_WINDOW){ streakCount++; } else { streakCount = 1; }
    lastCollectTime = t; streakMultiplier = 1 + Math.floor(Math.max(0, streakCount-1)/2); const gained = points * streakMultiplier; score += gained; spawnParticles(player.x + player.w/2, player.y + 30); playSfx('collect'); }

  // ======= PARTICLES update & draw (reused functions already exist) =======
  // definitions already above - keep consistent

  // ======= ECO FACTS =======
  const ecoFacts = [
    "Recycling one plastic bottle saves enough energy to power a light bulb for 3 hours!",
    "Glass can be recycled endlessly without losing quality.",
    "Every ton of recycled paper saves 17 trees.",
    "Composting can reduce household waste by up to 30%.",
    "Producing recycled aluminum uses 95% less energy than new aluminum.",
    "A single tree absorbs about 22 kg of CO2 every year."
  ];
  document.getElementById('facts').innerText = ecoFacts[Math.floor(Math.random()*ecoFacts.length)];

  // ======= INIT =======
  // initialise sizes & ground and start loop
  initParallax(); resizeCanvas(); startSpawners(); requestAnimationFrame(mainLoop);
  // small resize safety
  setTimeout(()=>{ resizeCanvas(); initParallax(); }, 80);

})();
</script>
</body>
</html>
