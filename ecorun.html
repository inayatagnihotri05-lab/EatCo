<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>EcoRun üåø ‚Äî EatCo</title>

  <!-- Google font -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --accent:#2e8b57;
      --bg1:#b4f0c6;
      --bg2:#eafaf0;
      --muted:#6aa87b;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: 'Poppins', system-ui, sans-serif;
      background: linear-gradient(to bottom, var(--bg1) 0%, var(--bg2) 60%);
      display:flex;
      flex-direction:column;
      align-items:center;
      min-height:100vh;
      color:#124b32;
    }

    h1{ color: #1f513f; margin: 14px 0 6px; font-size:20px; }

    /* game container with "moving street" */
    #gameContainer{
      position:relative;
      width:100%;
      max-width:900px;
      height:560px;
      border:4px solid #1f513f;
      border-radius:12px;
      overflow:hidden;
      background: linear-gradient(to top, #dfeee1 0%, #cbefd3 40%, #b6f0c2 100%);
      margin-bottom:12px;
      box-shadow: 0 12px 40px rgba(17,75,47,0.08);
    }

    /* road block */
    #gameContainer::before{
      content:"";
      position:absolute; left:0; right:0; bottom:0;
      height:170px;
      background: linear-gradient(#5a5a5a,#4a4a4a);
      z-index:1;
    }

    /* moving stripes */
    #gameContainer::after{
      content:""; position:absolute; left:0; bottom:85px;
      width:200%; height:10px;
      background-image: linear-gradient(90deg, transparent 0 40px, #f6e58d 40px 60px);
      background-size:160px 10px;
      z-index:2; opacity:.95;
      animation: moveStripe 2s linear infinite;
    }
    @keyframes moveStripe{ from{transform:translateX(0)} to{transform:translateX(-160px)} }

    /* canvas covers on top */
    #gameCanvas{
      position:absolute; left:0; top:0; width:100%; height:100%;
      z-index:3; display:block;
      touch-action: none; /* help mobile so we can intercept touch */
    }

    #instructions{ color:#155e2c; font-size:14px; margin:6px; text-align:center; }

    /* fact popup */
    #fact{
      display:none;
      position:absolute; left:50%; transform:translateX(-50%);
      bottom:20px; background:rgba(0,0,0,0.7); color:white;
      padding:10px 14px; border-radius:10px; z-index:6; max-width:85%;
      text-align:center; font-size:14px;
    }

    /* win overlay */
    #winOverlay{
      display:none;
      position:absolute; z-index:11; left:50%; top:50%;
      transform:translate(-50%,-50%); background:rgba(255,255,255,0.98);
      padding:26px; border-radius:14px; text-align:center; width:80%; max-width:420px;
      box-shadow:0 8px 30px rgba(0,0,0,0.15);
    }
    #winOverlay h2{ margin:0 0 8px; color:var(--accent) }
    .btn{
      display:inline-block; margin-top:10px; padding:8px 14px; border-radius:10px;
      text-decoration:none; color:white; background:var(--accent); border:none; cursor:pointer;
      font-weight:600;
    }
    .btn.secondary{ background:var(--muted); margin-left:10px }

    /* score box */
    #scoreBox{
      position:absolute; top:12px; left:12px; z-index:7;
      background:white; padding:8px 12px; border-radius:10px; font-weight:700;
      color: #155e2c; box-shadow:0 2px 10px rgba(0,0,0,0.12);
      display:flex; gap:12px; align-items:center;
    }
    #scoreBox small { font-weight:600; color:#2f6d48; }

    /* start overlay */
    #startOverlay{
      position:absolute; z-index:11; left:50%; top:50%;
      transform:translate(-50%,-50%); background:rgba(255,255,255,0.95);
      padding:22px; border-radius:12px; text-align:center; width:85%; max-width:420px;
      box-shadow:0 10px 30px rgba(0,0,0,0.12);
    }
    #startOverlay h3{ margin:0 0 8px; color:#155e2c }

    /* small controls row */
    #controls{
      margin-bottom:14px; display:flex; gap:8px; align-items:center; font-size:14px;
    }
    #muteBtn { background:#fff; border:1px solid #e6f0ea; padding:6px 8px; border-radius:8px; cursor:pointer; }

    @media (max-width:480px){
      #gameContainer{ height:420px }
    }
  </style>
</head>
<body>
  <h1>EcoRun üåç ‚Äî Save the Planet in Style</h1>

  <div id="controls">
    <div style="color:#155e2c; font-weight:600; margin-right:8px;">Controls:</div>
    <div style="background:white;padding:6px 8px;border-radius:8px;">Space / Tap</div>
    <button id="muteBtn" aria-label="Mute (no audio yet)">üîà Mute</button>
  </div>

  <div id="gameContainer" aria-label="EcoRun game area">
    <canvas id="gameCanvas"></canvas>
    <div id="scoreBox" aria-live="polite"><small id="hudScore">Score: 0</small><small id="hudBest">Best: 0</small></div>
    <div id="fact" role="status" aria-atomic="true"></div>

    <div id="startOverlay" role="dialog" aria-hidden="false">
      <h3>EcoRun</h3>
      <p>Press <b>SPACE</b> or <b>Tap</b> to jump. Collect eco items, avoid trash. üå±</p>
      <button id="startBtn" class="btn">Start Run</button>
    </div>

    <div id="winOverlay" role="dialog" aria-hidden="true">
      <h2>üéâ You Saved the Planet!</h2>
      <p id="winText">Final score: 0</p>
      <div style="margin-top:12px">
        <button id="playAgain" class="btn">Play Again</button>
        <button id="shareBtn" class="btn secondary">Share Score</button>
      </div>
    </div>
  </div>

  <p id="instructions">Press <b>SPACE</b> (or tap) to jump ‚Äî collect eco items, avoid trash. üå±</p>

  <!-- confetti lib -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

  <script>
  (() => {
    // --- config ---
    const WIN_SCORE = 10;        // score needed to win
    const OB_SPAWN_CHANCE = 0.01; // lower = easier
    const ITEM_SPAWN_CHANCE = 0.03;
    const SPEED = 4.2;           // base object speed
    // --------------

    const canvas = document.getElementById('gameCanvas');
    const container = document.getElementById('gameContainer');
    let ctx = canvas.getContext('2d');
    const factBox = document.getElementById('fact');
    const hudScore = document.getElementById('hudScore');
    const hudBest = document.getElementById('hudBest');
    const scoreBox = document.getElementById('scoreBox');
    const winOverlay = document.getElementById('winOverlay');
    const winText = document.getElementById('winText');
    const playAgainBtn = document.getElementById('playAgain');
    const shareBtn = document.getElementById('shareBtn');
    const muteBtn = document.getElementById('muteBtn');
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    // retina-aware canvas resize
    function resizeCanvas(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = container.clientWidth;
      const h = container.clientHeight;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      // reset transform & scale for drawing in CSS pixels
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', () => {
      resizeCanvas();
      // update ground when size changes
      groundY = container.clientHeight - 110;
    });
    resizeCanvas();

    // game state
    let player = { x: 120, y: 0, r: 36, vy:0, jumping:false };
    let groundY = container.clientHeight - 110;
    player.y = groundY - player.r/2; // center y
    const gravity = 0.6;

    let obstacles = [];
    let items = [];
    let score = 0;
    let best = parseInt(localStorage.getItem('eatco_best')||'0',10) || 0;
    let running = false;
    hudScore.textContent = `Score: ${score}`;
    hudBest.textContent = `Best: ${best}`;

    // eco facts
    const ECO_FACTS = [
      "üçé Eating local reduces CO‚ÇÇ by 13%!",
      "ü•¶ Broccoli absorbs carbon while growing.",
      "‚ôªÔ∏è Recycling one can saves enough energy to power a bulb for 3 hours!",
      "üö¥ Biking instead of driving cuts emissions by 80%.",
      "üåç Plant-based meals can cut carbon by 60%."
    ];

    // control: jump on space or tap
    function jump(){
      if (!running) return;
      if (!player.jumping){
        player.jumping = true;
        player.vy = -13 - Math.random()*4; // small variation
      }
    }
    // keyboard
    document.addEventListener('keydown', e => {
      if (e.code === 'Space' || e.key === ' ') {
        e.preventDefault();
        jump();
      }
    });
    // touch on container (prevent default to avoid page scroll)
    container.addEventListener('touchstart', e => {
      e.preventDefault();
      jump();
    }, { passive:false });

    // spawn functions (emoji chosen at spawn)
    function maybeSpawnObstacle(){
      if (Math.random() < OB_SPAWN_CHANCE) {
        const size = 36 + Math.round(Math.random()*18);
        const emojiChoices = ['ü•§','üçü','üóëÔ∏è','üß¥','üçï'];
        const emoji = emojiChoices[Math.floor(Math.random()*emojiChoices.length)];
        obstacles.push({
          x: container.clientWidth + 30,
          y: groundY - size/2,
          size,
          speed: SPEED + Math.random()*1.4,
          emoji
        });
      }
    }
    function maybeSpawnItem(){
      if (Math.random() < ITEM_SPAWN_CHANCE) {
        const size = 28 + Math.round(Math.random()*8);
        const y = groundY - (60 + Math.round(Math.random()*80));
        const emojiChoices = ['üçé','ü•¶','‚ôªÔ∏è','üçå','üçì'];
        const emoji = emojiChoices[Math.floor(Math.random()*emojiChoices.length)];
        items.push({
          x: container.clientWidth + 30,
          y,
          size,
          speed: SPEED - 0.6 + Math.random()*1.2,
          emoji
        });
      }
    }

    // show fact popup
    let factTimeout = null;
    function showFact(){
      const f = ECO_FACTS[Math.floor(Math.random()*ECO_FACTS.length)];
      factBox.textContent = f;
      factBox.style.display = 'block';
      clearTimeout(factTimeout);
      factTimeout = setTimeout(()=>factBox.style.display='none', 2200);
    }

    // confetti celebration
    function doConfetti(){
      const duration = 2.5 * 1000;
      const end = Date.now() + duration;
      (function frame(){
        confetti({
          particleCount: 10,
          startVelocity: 35,
          spread: 160,
          ticks: 60,
          origin: { x: Math.random(), y: Math.random()*0.6 },
        });
        if (Date.now() < end) requestAnimationFrame(frame);
      })();
    }

    function gameWin(){
      running = false;
      winText.textContent = `Final score: ${score}`;
      winOverlay.style.display = 'block';
      doConfetti();
      if (score > best) {
        best = score;
        localStorage.setItem('eatco_best', best);
        hudBest.textContent = `Best: ${best}`;
      }
    }

    playAgainBtn.addEventListener('click', ()=> location.reload());
    shareBtn.addEventListener('click', ()=> {
      const shareText = `I scored ${score} on EcoRun ‚Äî playing on EatCo! üåø Try it: ${location.href}`;
      if (navigator.share) navigator.share({title:'EcoRun score', text:shareText}).catch(()=>alert(shareText));
      else {
        navigator.clipboard.writeText(shareText).then(()=>alert('Score copied to clipboard ‚Äî share it!'));
      }
    });

    // mute toggle (no sounds included yet)
    let muted = false;
    muteBtn.addEventListener('click', ()=> {
      muted = !muted;
      muteBtn.textContent = muted ? 'üîá Muted' : 'üîà Mute';
    });

    // collision helpers (circle vs rect approx)
    function circleRectCollide(cx, cy, cr, rx, ry, rw, rh){
      // rx,ry are top-left
      const closestX = Math.max(rx, Math.min(cx, rx + rw));
      const closestY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - closestX;
      const dy = cy - closestY;
      return (dx*dx + dy*dy) <= (cr*cr);
    }

    // main loop
    function update(){
      if (!running) return;
      // physics - gravity
      player.vy += gravity;
      player.y += player.vy;

      // landing detection (player.y is center Y)
      const playerBottom = player.y + player.r/2;
      if (playerBottom > groundY) {
        player.y = groundY - player.r/2;
        player.vy = 0;
        player.jumping = false;
      }

      // clear
      ctx.clearRect(0,0,container.clientWidth,container.clientHeight);

      // draw ground shadow / parallax subtle
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, groundY + 8, container.clientWidth, 6);
      ctx.restore();

      // draw player shadow
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(player.x, groundY + 18, player.r * 0.7, 10, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fill();
      ctx.restore();

      // draw player (emoji) - use middle baseline
      ctx.font = `${player.r}px serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üèÉ‚Äç‚ôÇÔ∏è', player.x, player.y);

      // spawn
      maybeSpawnObstacle();
      maybeSpawnItem();

      // obstacles
      for (let i = obstacles.length-1; i>=0; i--){
        const ob = obstacles[i];
        ob.x -= ob.speed;
        ctx.font = `${ob.size}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(ob.emoji, ob.x, ob.y);

        // collision box - treat ob rectangle centered on ob.x,ob.y
        const obLeft = ob.x - ob.size/2;
        const obTop  = ob.y - ob.size/2;
        if (circleRectCollide(player.x, player.y, player.r*0.45, obLeft, obTop, ob.size, ob.size)) {
          // hit
          running = false;
          setTimeout(()=> alert(`üí• Game Over! Final Score: ${score}`), 60);
          setTimeout(()=> location.reload(), 140);
          return;
        }
        if (ob.x < -80) obstacles.splice(i,1);
      }

      // items
      for (let i = items.length-1; i>=0; i--){
        const it = items[i];
        it.x -= it.speed;
        ctx.font = `${it.size}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(it.emoji, it.x, it.y);

        const itLeft = it.x - it.size/2;
        const itTop  = it.y - it.size/2;
        if (circleRectCollide(player.x, player.y, player.r*0.45, itLeft, itTop, it.size, it.size)) {
          score += 1;
          showFact();
          items.splice(i,1);
          hudScore.textContent = `Score: ${score}`;
          if (score >= WIN_SCORE) { gameWin(); return; }
        }
        if (it.x < -80) items.splice(i,1);
      }

      // HUD in-canvas optional small text
      ctx.fillStyle = '#1f513f';
      ctx.font = '14px Poppins, sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(`Score: ${score}`, 12, 12);

      requestAnimationFrame(update);
    }

    // Start button
    startBtn.addEventListener('click', () => {
      startOverlay.style.display = 'none';
      running = true;
      // ensure canvas size & ground are current
      resizeCanvas();
      groundY = container.clientHeight - 110;
      // reset player to ground
      player.y = groundY - player.r/2;
      player.vy = 0;
      // begin loop
      requestAnimationFrame(update);
    });

    // allow tapping start overlay by pressing space as well
    document.addEventListener('keydown', e => {
      if ((e.code === 'Space' || e.key === ' ') && startOverlay.style.display !== 'none') {
        e.preventDefault();
        startBtn.click();
      }
    });

    // initialization: make sure hud shows best
    hudBest.textContent = `Best: ${best}`;

  })();
  </script>
</body>
</html>
